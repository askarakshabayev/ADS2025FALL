this the graph, here count of vertex and count of edges and the x, y, w
6 9
1 2 1
1 3 5
1 4 8
1 5 3
2 4 9
2 5 1 
2 6 2
3 4 4
5 6 6
the prim code is:

#include <iostream>
#include <vector>
#define mp make_pair
#define pb push_back

using namespace std;
int n, m, x, y, w;
vector<pair<int, int> > g[100];
int d[100];
int u[100];


int main() {
    cin >> n >> m; 
    for (int i = 0; i < m; i++) {
        cin >> x >> y >> w;
        x--;
        y--;
        g[x].pb(mp(y, w));
        g[y].pb(mp(x, w));
    }
    for (int i = 0; i < n; i++)
        d[i] = -1;
    d[0] = 0;
    for (int i = 0; i < n; i++) {
        int v = -1;
        for (int j = 0; j < n; j++) {
            if (u[j] == 0 && (v == -1 || (d[v] > d[j] && d[j] != -1)))
                v = j;
        }
        u[v] = 1;
        for (int j = 0; j < g[v].size(); j++) {
            int x = g[v][j].first;
            int w = g[v][j].second;
            if (u[x] == 0 && (d[x] == -1 || d[x] > w))
                d[x] = w;
        }
    }

    for (int i = 0; i < n; i++)
        cout << d[i] << " ";

    return 0;
}

and the kruskal
#include <iostream>
#include <vector>
#define pb push_back
#define mp make_pair

using namespace std;
vector<pair<int, pair<int, int> > > g;
int n, m, x, y, w;
int p[100];
int r[100];

int find(int v) {
    if (v == p[v])
        return v;
    p[v] = find(p[v]);
    return p[v];
}

void union_set(int v, int u) {
    v = find(v);
    u = find(u);
    if (r[v] < r[u])
        p[v] = u;
    else if (r[v] > r[u])
        p[u] = v;
    else {
        p[u] = v;
        r[u]++;
    }
}

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        cin >> x >> y >> w;
        x--;
        y--;
        g.pb(mp(w, mp(x, y)));
    }
    sort(g.begin(), g.end());
    for (int i = 0; i < n; i++)
        p[i] = i;

    for (int i = 0; i < m; i++) {
        int x = g[i].second.first;
        int y = g[i].second.second;
        if (find(x) != find(y)) {
            union_set(x, y); 
            cout << x + 1 << " " << y + 1 << endl;
        }
    }
    return 0;
}

change the implemation and example of graph on lecture 12